C/C++

Peter Loos

Freitag

// =======================================================

https://github.com/pelocpp

// =======================================================

===>   Abspann Yes ...

===>   STL:    PhoneBook    // Hash-Tabelle:  Yes ...

===>   void* Pointer   Yes ...

===>   Range-Based for-Loop

===>   Lambdas: Yes ...

===>   auto

===>   Range-Based for-Loop für ein beliebiges Objekt

===>   File lesen // kopieren ....   Yes ...

// =======================================================

Hash - Tabelle:
---------------

Aufbau:

Sie enthält Werte und Schlüssel.

Beispiel:

Wörterbuch:  Deutsch /             Englisch

             Key / Schlüssel       Wert / Value

             "Guten Morgen"        "Good morning"


Telefonbuch:

             Key / Schlüssel       Wert / Value

             "Mueller"             34534534


Hash-Tabelle:  Enthält viele Paare


Hash-Funktionen:   Schlüssel        ===> INDEX

                   "Hans Mueller"   ===> 152

                   "Tina Meier"     ===> 152

                   Kollision aufzulösen:

                   Durch eine verkettete Liste kann man
                   Werte desselben Index am selben Index
                   unterbringen.

// ========================================================

std::unordered_map<std::string, size_t>   // Hashtabelle

std::pair

// ========================================================

ignorieren
discarding return value of function with [[nodiscard]] attribute	

// ========================================================

std::optional<size_t> number;

A) bool

C) realem Wert

// ========================================================

        std::for_each(
            m_data.begin(),
            m_data.end(),
            A) Funktion
        );


Was ist eine Lambda-Funktion

Eine Funktion OHNE Namen, die inplace an bestimmten Stellen
formulierbar ist.

// ========================================================

Was ist eine Lambda-Funktion:

KEINE FUNKTION:   FALSCH

ES IST EIN OBJEKT.

===> Instanzvariablen


[ i = 0 ]    ===>    Type Deduction

===========================================================


High-End
--------

std::function:

==> Lambda
==> C-Funktion
==> Callable
==> Methode
==> C-Funktionszeiger
==>    aufrufen 

TECHNIK:    TYPE ERASURE

std::any

/////////////////////////////////////////////////////////////

Lambdas:


https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md

// =======================================================


Ab C++ C++ 17:

Neues File-API:

Siehe Datei "FileSystem.cpp" in diesem RePo.

Siehe auch

Filesystem library (since C++17)

https://en.cppreference.com/w/cpp/filesystem

// =======================================================

void*

A) Als Anwender haben wir mit void* eigentlich
   keine Berührung.

B) malloc (C)

   new (C++)

   std::malloc

// =======================================================

C++:

Dynamische Speicherverwaltung:

new

===> Smart Pointer

std::unique_ptr   ===> Klassischer Zeiger:

                  Klärt Ownership !

                  Move



std::shared_ptr   ===> "Easy - GC Typ"

(( std::weak_ptr ))

Win-Situation: no delete  // wird von diesen Klassen
  übernommen

===>   RAII:  

// =======================================================

Realisierung eines Iterators:

Siehe auch

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Exercises/Exercises_STL_Lotto.md

// =======================================================
